"""AgentPy participant definitions for Feels simulation.

Defines heterogeneous agent types that represent different market participants
including retail traders, algorithmic traders, liquidity providers, and arbitrageurs.
Each agent type has distinct behavioral patterns and market impact characteristics.
"""

from __future__ import annotations

import math
from dataclasses import dataclass
from typing import Any, Dict, List, Optional, Tuple

import agentpy as ap


@dataclass
class TradeOrder:
    """Trade order generated by participants for execution.
    
    Represents a trading intent from a participant including size, direction,
    timestamp, and urgency for proper execution prioritization.
    """
    participant_id: str        # ID of the participant generating the order
    participant_type: str      # Type of participant (retail, algo, arbitrageur)
    size: float               # Size of the trade in FeelsSOL
    is_buy: bool              # True for buy orders, False for sell orders
    timestamp: int            # Simulation minute when order was generated
    urgency: float            # Urgency level (0.0 = patient to 1.0 = urgent)


class ParticipantBase(ap.Agent):
    """Base class for all trading participants in the simulation.
    
    Provides common interface and utility methods for different participant types.
    Each participant implements its own trading logic while sharing state management.
    Inherits from AgentPy's Agent class for proper integration with the framework.
    """
    
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.id = str(self.id)  # AgentPy assigns numeric IDs, convert to string
        self.last_action_time: int = -1  # Track last trading activity
        # Add other common attributes if necessary
    
    def should_trade(self, current_time: int, market_conditions: Dict) -> bool:
        """Determine if the participant should trade at this time.
        
        Args:
            current_time: Current simulation minute
            market_conditions: Dictionary of current market state
            
        Returns:
            True if participant should generate a trade order
        """
        return False  # Default: no trading
    
    def generate_trade(self, current_time: int, market_conditions: Dict) -> Optional['TradeOrder']:
        """Generate a trade order if conditions are met.
        
        Args:
            current_time: Current simulation minute
            market_conditions: Dictionary of current market state
            
        Returns:
            TradeOrder if trading, None otherwise
        """
        return None  # Default: no trade generated


@dataclass
class ParticipantConfig:
    """Configuration parameters for diverse agent populations.
    
    Defines behavioral characteristics for different trader types including
    frequency, size distributions, fee sensitivity, and market responsiveness.
    Used to calibrate realistic trading patterns in the simulation.
    """
    # Retail trader configuration - frequent small trades with high fee sensitivity
    retail_count: int = 25                       # Number of retail trading agents
    retail_base_frequency: float = 120.0         # Base trades per day (~5 per hour)
    retail_size_mean: float = 18.0               # Average trade size in FeelsSOL
    retail_size_variance: float = 0.5            # Trade size variability factor
    retail_fee_sensitivity: float = 2.0          # Sensitivity to fee changes (elasticity)
    retail_sentiment_sensitivity: float = 0.5    # Response to price momentum

    # Algorithmic trader configuration - higher frequency, larger sizes, less fee sensitive
    algo_count: int = 3                          # Number of algorithmic agents
    algo_base_frequency: float = 60.0            # Base trades per day (â‰ˆ2.5 per hour)
    algo_size_mean: float = 100.0                # Average trade size in FeelsSOL
    algo_size_variance: float = 0.6              # Trade size variability factor
    algo_fee_sensitivity: float = 0.5            # Lower fee sensitivity than retail
    algo_sentiment_sensitivity: float = 0.2      # Less momentum-driven trading

    # Liquidity provider configuration - concentrated positions with fee harvesting
    lp_count: int = 10                           # Number of LP agents
    lp_position_size_mean: float = 500.0         # Average position size in FeelsSOL
    lp_position_size_variance: float = 0.6       # Position size variability
    lp_fee_sensitivity: float = 3.0              # High sensitivity to fee earning potential
    lp_rebalance_frequency: float = 6.0          # Position rebalancing frequency (hours)

    # Arbitrageur configuration - price discrepancy exploitation
    arb_count: int = 1                           # Number of arbitrage agents
    arb_size_mean: float = 25.0                  # Average arbitrage trade size
    arb_threshold_bps: float = 40.0              # Minimum profit threshold (basis points)
    arb_response_time: float = 2.0               # Minutes to respond to opportunities


@dataclass
class LiquidityPosition:
    """Concentrated liquidity position for market making.
    
    Represents a single LP position with defined tick range and size.
    Tracks fee accumulation and position lifecycle for LP yield calculations.
    """
    participant_id: str      # ID of the LP that owns this position
    size: float              # Position size in FeelsSOL
    tick_lower: int          # Lower tick bound for liquidity provision
    tick_upper: int          # Upper tick bound for liquidity provision
    timestamp_created: int   # Simulation minute when position was created
    fees_earned: float = 0.0 # Cumulative fees earned from this position
    
    # Backward compatibility properties
    @property
    def created_minute(self) -> int:
        """Backward compatibility property for created_minute."""
        return self.timestamp_created


class TraderAgent(ap.Agent):
    """Base class for all trading agents in the simulation.
    
    Provides common interface and utility methods for different trader types.
    Each trader implements its own trading logic while sharing state management.
    """

    participant_type: str = "trader"  # Type identifier for metrics tracking

    def setup(self) -> None:
        """Initialize agent state for simulation lifecycle."""
        self.last_action_minute: int = -1  # Track last trading activity
        self.sentiment: float = 0.0        # Price momentum sentiment (-1 to 1)

    def _rng(self):
        """Access model's random number generator for consistent seeding."""
        return self.model.random

    def _market_ctx(self) -> Dict[str, Any]:
        """Access current market context including prices and volatility."""
        return self.model.market_ctx

    def trade(self) -> Dict[str, float]:
        """Execute trading decision for current simulation step.
        
        Returns:
            Dictionary with 'net' (signed volume) and 'abs' (total volume)
        """
        return {"net": 0.0, "abs": 0.0}  # Default: no trading


class RetailTraderAgent(TraderAgent):
    """Retail trader with high fee sensitivity and momentum following behavior.
    
    Represents individual traders who make smaller, more frequent trades.
    Highly sensitive to fees and tend to follow price momentum patterns.
    """
    participant_type = "retail"  # Identifier for retail trader type

    def trade(self) -> Dict[str, float]:
        """Execute retail trading logic with fee sensitivity and momentum.
        
        Retail traders have high fee sensitivity and follow price momentum.
        Trading frequency decreases with higher fees and increases with volatility.
        """
        cfg = self.model.participant_config  # Access trader configuration
        ctx = self._market_ctx()             # Get current market state
        minute = ctx["minute"]               # Current simulation minute
        fee_rate = ctx["fee_rate"]           # Current fee rate
        volatility = abs(ctx.get("price_change", 0.0))  # Recent price volatility

        # Calculate trading probability based on multiple factors
        base_prob = cfg.retail_base_frequency / (24 * 60)  # Convert hourly frequency to per-minute
        fee_penalty = 1.0 / (1.0 + fee_rate * cfg.retail_fee_sensitivity * 500)  # Reduce activity with high fees
        volatility_boost = 1.0 + volatility * cfg.retail_sentiment_sensitivity  # Increase activity during volatility
        probability = max(0.0, min(1.0, base_prob * fee_penalty * volatility_boost))  # Final trading probability

        # Skip trading if probability check fails
        if self._rng().random() >= probability:
            return {"net": 0.0, "abs": 0.0}

        # Update sentiment based on recent price movements (momentum following)
        price_change = ctx.get("price_change", 0.0)
        self.sentiment = 0.7 * self.sentiment + 0.3 * price_change  # Exponential smoothing

        # Determine trade size using log-normal distribution (realistic size variation)
        size = self._rng().lognormvariate(
            math.log(max(cfg.retail_size_mean, 1e-6)),  # Mean trade size
            cfg.retail_size_variance,                   # Size variability
        )
        
        # Determine trade direction based on sentiment (momentum following)
        buy_probability = 0.5 + self.sentiment * 0.3  # Bias toward recent price direction
        is_buy = self._rng().random() < max(0.0, min(1.0, buy_probability))

        self.last_action_minute = minute  # Record trading activity
        net = size if is_buy else -size   # Positive for buy, negative for sell
        return {"net": net, "abs": size}


class AlgoTraderAgent(TraderAgent):
    """Algorithmic trader with sophisticated strategies and lower fee sensitivity.
    
    Automated trading systems with systematic strategies, higher frequency,
    larger sizes, and ability to profit from volatility and inefficiencies.
    """
    participant_type = "algo"

    def trade(self) -> Dict[str, float]:
        """Execute algorithmic trading logic with lower fee sensitivity and mean reversion.
        
        Algo traders trade more frequently, use larger sizes, and implement
        systematic strategies that often fade momentum (contrarian approach).
        """
        cfg = self.model.participant_config  # Access algo configuration
        ctx = self._market_ctx()             # Get current market conditions
        fee_rate = ctx["fee_rate"]           # Current fee rate
        volatility = abs(ctx.get("price_change", 0.0))  # Market volatility

        # Calculate trading probability with lower fee sensitivity
        base_prob = cfg.algo_base_frequency / (24 * 60)  # Higher frequency than retail
        fee_penalty = 1.0 / (1.0 + fee_rate * cfg.algo_fee_sensitivity * 200)  # Less fee sensitive
        volatility_boost = 1.0 + volatility * 0.5  # Volatility creates trading opportunities
        probability = max(0.0, min(1.0, base_prob * fee_penalty * volatility_boost))

        # Skip trading if conditions not met
        if self._rng().random() >= probability:
            return {"net": 0.0, "abs": 0.0}

        # Generate larger trade size reflecting institutional capital
        size = self._rng().lognormvariate(
            math.log(max(cfg.algo_size_mean, 1e-6)),  # Larger base size than retail
            cfg.algo_size_variance,                   # Size distribution
        )
        
        # Implement mean reversion strategy (fade momentum)
        recent_trend = ctx.get("price_change", 0.0)
        buy_probability = 0.5 - recent_trend * 0.2  # Contrarian bias
        is_buy = self._rng().random() < max(0.0, min(1.0, buy_probability))

        net = size if is_buy else -size  # Signed volume
        return {"net": net, "abs": size}


class ArbitrageurAgent(TraderAgent):
    """Arbitrageur that exploits price discrepancies for risk-free profit.
    
    Specialized traders who identify and capture temporary price inefficiencies
    between markets or relative to fair value. Highly efficient and urgent.
    """
    participant_type = "arbitrageur"

    def trade(self) -> Dict[str, float]:
        """Execute arbitrage trades when profit opportunities exceed threshold.
        
        Only trades when price discrepancy is large enough to ensure profitability
        after fees. Trade size scales with opportunity size.
        """
        cfg = self.model.participant_config  # Access arbitrageur configuration
        ctx = self._market_ctx()             # Get current market state
        discrepancy = ctx.get("price_discrepancy", 0.0)  # Price gap vs fair value
        threshold = cfg.arb_threshold_bps / 10_000.0     # Minimum profit threshold

        # Only trade if opportunity exceeds minimum threshold
        if abs(discrepancy) < threshold:
            return {"net": 0.0, "abs": 0.0}

        # Scale trade size based on opportunity magnitude
        multiplier = min(3.0, abs(discrepancy) / threshold)  # Cap at 3x base size
        size = cfg.arb_size_mean * multiplier               # Larger gaps = larger trades
        is_buy = discrepancy < 0  # Buy if price below fair value, sell if above
        net = size if is_buy else -size  # Trade direction opposes discrepancy
        return {"net": net, "abs": size}


class LiquidityProviderAgent(ap.Agent):
    participant_type = "lp"

    def setup(self) -> None:
        cfg = self.model.participant_config
        self.positions: List[LiquidityPosition] = []
        self.total_fees_realized: float = 0.0
        self.reserve = self.model.random.lognormvariate(
            math.log(max(cfg.lp_position_size_mean, 1e-6)),
            cfg.lp_position_size_variance,
        )
        self._ensure_position(self.model.market_ctx["tick"], self.model.market_ctx["minute"])

    def _sample_width(self) -> int:
        cfg = self.model.participant_config
        base_ticks = max(10, cfg.lp_rebalance_frequency * self.model.p["tick_spacing"])
        width = int(base_ticks * self.model.random.randint(2, 6))  # randint is inclusive, so 2-6 gives same range as integers(2,7)
        return max(self.model.p["tick_spacing"], width)

    def _ensure_position(self, tick: int, minute: int) -> None:
        if self.reserve <= 0:
            return
        width = self._sample_width()
        size = min(
            self.reserve,
            self.model.random.lognormvariate(
                math.log(max(self.model.participant_config.lp_position_size_mean, 1e-6)),
                self.model.participant_config.lp_position_size_variance,
            ),
        )
        if size <= 0:
            return
        position = LiquidityPosition(
            participant_id=str(self.id),
            size=size,
            tick_lower=tick - width // 2,
            tick_upper=tick + width // 2,
            timestamp_created=minute,
        )
        self.positions.append(position)

    def step(self) -> None:
        cfg = self.model.participant_config
        ctx = self.model.market_ctx
        tick = ctx["tick"]
        minute = ctx["minute"]
        lifetime_limit = cfg.lp_rebalance_frequency * 120

        retained: List[LiquidityPosition] = []
        for position in self.positions:
            out_of_range = position.tick_upper < tick or position.tick_lower > tick
            expired = (minute - position.created_minute) > lifetime_limit
            if out_of_range or expired:
                self.total_fees_realized += position.fees_earned
            else:
                retained.append(position)
        self.positions = retained

        if self.model.random.random() < 0.3:
            self._ensure_position(tick, minute)

    def active_liquidity(self, tick: int) -> float:
        return sum(
            position.size for position in self.positions if position.tick_lower <= tick <= position.tick_upper
        )

    def iter_overlaps(self, start_tick: int, end_tick: int) -> List[Tuple[LiquidityPosition, float]]:
        path_min = min(start_tick, end_tick)
        path_max = max(start_tick, end_tick)
        overlaps: List[Tuple[LiquidityPosition, float]] = []
        for position in self.positions:
            overlap = max(
                0,
                min(position.tick_upper, path_max) - max(position.tick_lower, path_min),
            )
            if overlap > 0 and position.size > 0:
                overlaps.append((position, position.size * overlap))
        if not overlaps and self.positions:
            # Fallback to positions covering end tick (single-point trade)
            for position in self.positions:
                if position.tick_lower <= end_tick <= position.tick_upper:
                    overlaps.append((position, position.size))
        return overlaps


@dataclass
class ParticipantRegistry:
    retail: ap.AgentList
    algo: ap.AgentList
    arbitrageurs: ap.AgentList
    liquidity_providers: ap.AgentList

    @property
    def trader_agents(self) -> List[TraderAgent]:
        agents: List[TraderAgent] = []
        agents.extend(self.retail)
        agents.extend(self.algo)
        agents.extend(self.arbitrageurs)
        return agents

    def note_market_tick(self, tick: int) -> None:
        self._last_tick = tick  # Stored for diagnostics; no additional action required.

    def active_liquidity(self, tick: int) -> float:
        return sum(lp.active_liquidity(tick) for lp in self.liquidity_providers)

    def accrue_lp_fees(self, amount: float, start_tick: int, end_tick: int) -> float:
        if amount <= 0:
            return 0.0
        contributions: List[Tuple[LiquidityPosition, float]] = []
        for lp in self.liquidity_providers:
            contributions.extend(lp.iter_overlaps(start_tick, end_tick))

        total_weight = sum(weight for _, weight in contributions if weight > 0)
        if total_weight <= 0:
            return 0.0

        distributed = 0.0
        for position, weight in contributions:
            share = amount * (weight / total_weight)
            position.fees_earned += share
            distributed += share
        return distributed


def create_participant_registry(model: ap.Model, config: ParticipantConfig) -> ParticipantRegistry:
    retail = ap.AgentList(model, max(config.retail_count, 0), RetailTraderAgent)
    algo = ap.AgentList(model, max(config.algo_count, 0), AlgoTraderAgent)
    arbs = ap.AgentList(model, max(config.arb_count, 0), ArbitrageurAgent)
    lps = ap.AgentList(model, max(config.lp_count, 0), LiquidityProviderAgent)

    return ParticipantRegistry(
        retail=retail,
        algo=algo,
        arbitrageurs=arbs,
        liquidity_providers=lps,
    )


def aggregate_participant_metrics(registry: Optional[ParticipantRegistry], current_tick: int) -> Dict[str, Any]:
    if registry is None:
        return {}

    total_participants = (
        len(registry.retail)
        + len(registry.algo)
        + len(registry.arbitrageurs)
        + len(registry.liquidity_providers)
    )

    total_lp_positions = sum(len(lp.positions) for lp in registry.liquidity_providers)
    active_liquidity = registry.active_liquidity(current_tick)
    realized_fees = sum(lp.total_fees_realized for lp in registry.liquidity_providers)
    unrealized_fees = sum(
        position.fees_earned for lp in registry.liquidity_providers for position in lp.positions
    )

    return {
        "total_participants": total_participants,
        "retail_count": len(registry.retail),
        "algo_count": len(registry.algo),
        "lp_count": len(registry.liquidity_providers),
        "arb_count": len(registry.arbitrageurs),
        "total_lp_positions": total_lp_positions,
        "total_lp_fees": realized_fees + unrealized_fees,
        "total_lp_fees_realized": realized_fees,
        "total_lp_unrealized_fees": unrealized_fees,
        "active_lp_liquidity": active_liquidity,
    }
